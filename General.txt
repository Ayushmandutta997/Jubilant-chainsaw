Find subarrays in array
In general, for an array/string of size n, there are n*(n+1)/2 non-empty subarrays/substrings
void subArray(int arr[], int n)
{
    for (int i=0; i <n; i++)
    {
        for (int j=i; j<n; j++)
        {
            for (int k=i; k<=j; k++)
                cout << arr[k] << " ";
 
            cout << endl;
        }
    }
}
Find subsequences in array
void printSubsequences(int arr[], int n)
{
    /* Number of subsequences is (2**n -1)*/
    unsigned int opsize = pow(2, n);
 
    /* Run from counter 000..1 to 111..1*/
    for (int counter = 1; counter < opsize; counter++)
    {
        for (int j = 0; j < n; j++)
        {
            /* Check if jth bit in the counter is set
                If set then print jth element from arr[] */
            if (counter & (1<<j))
                cout << arr[j] << " ";
        }
        cout << endl;
    }
}
Check if a string S has subsequence target

#include <bits/stdc++.h>
using namespace std;

// Function to check if target
// is a subsequence of string S
void checkforSubsequence(string S,string target)
{

	// Declare a stack
	stack<char> s;

	// Push the characters of
	// target into the stack
	for (int i = 0; i < target.size(); i++) {
		s.push(target[i]);
	}

	// Traverse the string S in reverse
	for (int i = (int)S.size() - 1; i >= 0; i--) {

		// If the stack is empty
		if (s.empty()) {

			cout << "Yes" << endl;
			return;
		}

		// if S[i] is same as the
		// top of the stack
		if (S[i] == s.top()) {

			// Pop the top of stack
			s.pop();
		}
	}

	// Stack s is empty
	if (s.empty())
		cout << "Yes" << endl;
	else
		cout << "No" << endl;
}

int main()
{
	string S = "KOTTAYAM";
	string target = "KOTA";

	checkforSubsequence(S, target);

	return 0;
}

Sort string in o(n) complexity

#include<bits/stdc++.h>
using namespace std;

const int MAX_CHAR = 26;

void sortString(string &str)
{
	// Hash array to keep count of characters.
	// Initially count of all characters is
	// initialized to zero.
	int charCount[MAX_CHAR] = {0};
	
	// Traverse string and increment
	// count of characters
	for (int i=0; i<str.length(); i++)

		// 'a'-'a' will be 0, 'b'-'a' will be 1,
		// so for location of character in count
		// array we will do str[i]-'a'.
		charCount[str[i]-'a']++;
	
	// Traverse the hash array and print
	// characters
	for (int i=0;i<MAX_CHAR;i++)
		for (int j=0;j<charCount[i];j++)
			cout << (char)('a'+i);
}

int main()
{
	string s = "helloworld";
	sortString(s);
	return 0;
}

Permutations of a given string using STL
We can use next_permutation that modifies a string so that it stores lexicographically next permutation. If current string is lexicographically largest, i.e., “CBA”, then next_permutation returns false.
We first sort the string, so that it is converted to lexicographically smallest permutation. Then we one by one call next_permutation until it returns false.

#include <bits/stdc++.h>
using namespace std;

// Function to print permutations of string str
// using next_permutation
void permute(string str)
{
	// Sort the string in lexicographically
	// ascending order
	sort(str.begin(), str.end());

	// Keep printing next permutation while there
	// is next permutation
	do {
	cout << str << endl;
	} while (next_permutation(str.begin(), str.end()));
}
int main()
{
	string str = "CBA";
	permute(str);
	return 0;
}
Time complexity - o(n)
-------------
unordered map
map (like set) is an ordered sequence of unique keys whereas in unordered_map key can be stored in any order, 
so unordered. The map is implemented as a balanced tree structure that is why it is possible to maintain order 
between the elements (by specific tree traversal). The time complexity of map operations is O(log n) while for 
unordered_map, it is O(1) on average.
set,multimap,Unordered_set,Unordered_multiset,Unordered_multimap are similar 
---------------
priority queue - Priority queues are a type of container adapters, specifically designed such that the first
element of the queue is the greatest of all elements in the queue and elements are in nonincreasing order
priority_queue<int> gq - maxheap
priority_queue<int, vector<int>, greater<int> > gq - meanheap

